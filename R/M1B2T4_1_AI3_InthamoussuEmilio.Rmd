---
title: 'MÓDULO 1: HERRAMIENTAS BIG DATA'
author: "Emilio Inthamoussu"
date: "2024-12-26"
output:
  html_document:
    df_print: paged
  word_document: null
subtitle: "HERRAMIENTAS DE ANALISIS: PROGRAMACIÓN EN R - MICROACTIVIDADES 2"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(pander)
library(kableExtra)
options(knitr.kable.NA = '')
```

# EJERCICIO 2

Cargamos datos de nuevo.

```{r, include=FALSE}
library(datos)
suppressPackageStartupMessages(library(tidyverse))
```

## EJERCICIO 2.1.

Escribe un bucle `for` que guarda en nuevo data frame, la media de las columnas numéricas (de tipo integer o numeric) de `millas`. Presenta mediante `print` el data frame de resumen.

```{r}
# Solución:
# se inicializa un dataframe
millas2 <- NA
millas2 <- as.data.frame(millas2)

# se recorren las columnas de la tabla millas
for(i in 1:ncol(millas)){

  #si la columna es de clase INTEGER o NUMERIC, entonces se ingresa al IF
  if(class(millas[[i]]) == "integer" | class(millas[[i]]) == "numeric"){

    #se agrega un campo "aux_name" al dataframe millas2 con el promedio de la columna
    millas2$aux_name <- mean(millas[[i]])
    
    #se modifica el nombre de la columna, de "aux_name" al nombre correcto de la tabla millas.
    colnames(millas2)[which(names(millas2) == "aux_name")] <- names(millas[i])

  }
}

#se borra la primer columna que tenía valor NA
millas2 <- millas2 %>% select(-c(names(millas2[1])))
#se borra los datos innecesarios
rm(i)

print(millas2)

```


## EJERCICIO 2.2.

Haz lo mismo que en 2.1 pero utilizando `sapply()` en vez del bucle for.

```{r, warning=FALSE}
# Solución:
#en millas3 se almacena el resultado de aplicar el promedio a todas las columnas de millas.
millas3 <- sapply(millas, function(x) mean(x))
#se convierte millas3 en dataframe
millas3 <- as.data.frame(millas3)
#se aprovecha a quitar los valores NA, correspondientes a las "columnas" no numéricas. Digo columnas, pero la transformación a dataframe dejó  el dataframe en formato "clave-valor", por eso se usa el "filter".
millas3 <- millas3 %>% filter(!is.na(millas3))

# al pasarlo a dataframe, queda en formato columnar, y lo queremos en formato tabular como siempre.
# para eso se genera un vector con los row.names, que van a ser los column names.
headers <- row.names(millas3)
# y obtenemos otro vector con los datos, estos están en la primer columna
millas3 <- millas3[,1]

#se transforma estos datos en lista y luego en dataframe, para que queden 5 columnas y una fila
millas3 <- as.data.frame.list(millas3)
#se estampan los nombres correctos de las columnas.
names(millas3) <- headers

#se borran datos no neceasrios.
rm(headers)

#se imprime en pantalla
print(millas3)

```

## EJERCICIO 2.3.

Explica la diferencia entre la función `if()` e `ifelse()`. Pon un ejemplo de uso de ambas.

La principal diferencia, es que la función `if()` evalúa un solo valor lógico, en tanto que la función `ifelse()` evalúa muchos a la vez.
Por ejemplo, tomaremos un subconjunto de la tabla `millas` y se agregará una nueva columna que categorizará los datos.
En detalle, se traen todos los autos marca *Audi* y se evalúa como categoría *alta* aquellos vehículos con más de 4 cilindros, y como categoría *media* el resto de los vehículos.
Primero con la función `ifelse()`.

```{r}
# Solución:
#se genera el subconjunto de millas
millas4 <- millas %>% filter(fabricante=="audi") %>% select(fabricante,modelo,cilindrada,cilindros)
print(millas4)

#se utiliza la función ifelse para categorizar todas las filas
millas4$categoria <- ifelse(millas4$cilindros > 4,"alta","media")
print(millas4)

```

Se puede observar que quedó lista la columna *categoria* con los dos valores posibles asigandos a cada fila.
Ahora, con la función `if()` intentaremos hacer lo mismo:

```{r, error=TRUE}

if(millas4$cilindros > 4){
  millas4$categoria = "ALTA2"
} else {
  millas4$categoria = "MEDIA2"
}

```

Se observa que no permite hacerlo para toda la tabla. Lo que sí permite es hacer para un registro en particular.
Por ejemplo, para el primer registro.

```{r}

if(millas4$cilindros[1] > 4){
  millas4$categoria[1] = "ALTA2"
} else {
  millas4$categoria[1] = "MEDIA2"
}

print(millas4)
```

## EJERCICIO 2.4.

¿Qué parámetros son imprescindibles especificar cuando se leen datos de ancho fijo mediante: `read.fwf()`?

Explica qué significan y pon un ejemplo.

Los 2 argumentos mandatorios son *file* y *widths*. El primero refiere al archivo o conexión que tiene los datos. El segundo es un vector de enteros que refiere a los caracteres que ocupa cada campo.
En el ejemplo vamos a guardar un archivo simple en el directorio local y lo vamos a leer con la función `read.fwf()`.


```{r}
# Solución:
write(paste0("audi    a4  ","\n","audi    a6  ","\n","audi    a8  "),"einthamoussu_prueba_ej_2_4.txt")

#Se procede a leer el archivo, indicando que el primer campo es de 8 caracteres y el segundo es de 4:
kable(read.fwf("einthamoussu_prueba_ej_2_4.txt",c(8,4)))

#Se procede a leer el archivo, indicando que el primer campo es de 2 caracteres y el segundo es de 10:
kable(read.fwf("einthamoussu_prueba_ej_2_4.txt",c(2,10)))


```


## EJERCICIO 2.5.

Calcula la media de millas/galón en autopista para cada `clase` de coche de `millas`.

Presenta la tabla obtenida.

```{r}
# Solución:
mpg_autopista_por_clase_2_5 <- aggregate(millas$autopista, list(millas$clase), FUN=mean) 
names(mpg_autopista_por_clase_2_5) <- c("clase","autopista_clase")

kable(mpg_autopista_por_clase_2_5)

```

## EJERCICIO 2.6.

Incorpora la media de calculada en 2.5. en el data frame `millas` como una nueva columna llamada "autopista_clase". 

> Utiliza la funcion `merge()` para juntar el objeto obtenido en 2.5 con `millas`.

Presenta el summary() de la nueva columna.

```{r}
# Solución:

millas2 <- merge(millas,mpg_autopista_por_clase_2_5)

summary(millas2)

```

## EJERCICIO 2.7.

Utiliza las funciones del package dplyr: `group_by()` y `mutate()` para realizar el mismo calculo que en 2.5. y 2.6. sin necesidad de utilizar `merge()`. Llama a la nueva columna "autopista_clase_dplyr"

> Truco: Utiliza el siguiente ejemplo: `datos %>% group_by(var_seg) %>% mutate(nueva_variable=mean(variable))`

Haz un `summary()` para verificar que el resultado es el mismo que en 2.6.

```{r}
# Solución:
summary(millas %>% group_by(clase) %>% mutate(autopista_clase_dplyr=mean(autopista)))

```

## EJERCICIO 2.8.

Analiza si `millas` tiene registros duplicados y en caso afirmativo crea un nuevo data frame que contenga una única copia de cada fila.

```{r}
# Solución:
millas9 <- millas
millas9$duplicados <- ifelse(duplicated(millas9),"TRUE","FALSE")

kable(millas9 %>% group_by(duplicados) %>% summarize(cantidad = n()))


```
Aparecen 9 duplicados, que son:

```{r}
millas9 %>% filter(duplicados == "TRUE")
```

Para quitar los duplicados, nos quedamos sólo con los que tienen valor "FALSE" en el campo *duplicados*, y se guarda el resultado en un dataframe, quitando también la columna *duplicados* que ya no es necesaria.

```{r}
millas9 <- millas9 %>% filter(duplicados == "FALSE") %>% select(-duplicados)

str(millas9)

```

El total de registros de la dataframe bajó a 225, y si se ejecuta la función `duplicated()`, se ve que todos son FALSE:
```{r}

duplicated(millas9)

```


## EJERCICIO 2.9.

Crea una función que tenga como input la fecha de tu nacimiento (en formato date) y devuelva tu edad en años.

```{r}
# Solución:
library(lubridate)
edad <- function(fecha_nacimiento){

  #se valida que el parametro ingresado es de tipo Date  
  stopifnot(is.Date(fecha_nacimiento))

  #se devuelven los años.
  #   la resta de today - fecha_nacimiento da la cantidad de días
  #   con as.duration, se calculan los segundos transcurridos
  #   con as.period se obtiene una clase Period donde se puede extraer facilmente los años con
  #   year()
  return(paste0("Tienes ",as.duration(today()-fecha_nacimiento) %>% as.period() %>% year(), " años."))
  
}

#fecha de nacimiento
fecha <- as.Date("1981-07-26")

#llamado a funcion
edad(fecha)

```

## EJERCICIO 2.10.

Explica porqué el resultado de fechahora_1 y fechahora_2 son distintos en la siguiente expresión:

```{r, warning=FALSE, message=FALSE}
library(lubridate)
Sys.setlocale(locale="es_ES.UTF-8")
fechahora <- ymd_hms("2020-03-28 15:11:23", tz = "Europe/Madrid")
fechahora_1 <- fechahora + dhours(24)
fechahora_2 <- fechahora + hours(24)

print(fechahora_1)
print(fechahora_2)
```
Esto se debe a que `dhours()` tiene en cuenta el horario de verando/ horario de invierno, al hacer los cálculos. En españa el 30/03 se adelanta una hora para establecer el horario de verano.
La función `hours()` no tiene en cuenta esto para hacer la cuenta.
